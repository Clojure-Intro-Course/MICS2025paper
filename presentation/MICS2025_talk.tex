\documentclass{beamer}
\usepackage{beamerthemeshadow}
\usepackage{color}
\usepackage[all]{xy}

%% Elena's favorite green (thanks, Fernando!)
\definecolor{ForestGreen}{RGB}{34,139,34}
\definecolor{BlueViolet}{RGB}{138,43,226}
\definecolor{Coquelicot}{RGB}{255, 56, 0}
\definecolor{Teal}{RGB}{2,132,130}
%Uncomment this if you want to show work-in-progress comments
\newcommand{\comment}[1]{{\bf \tt  {#1}}}
% Uncomment this if you don't want to show comments
%\newcommand{\comment}[1]{}
% for color names see https://www.overleaf.com/learn/latex/Using_colors_in_LaTeX
\newcommand{\emcomment}[1]{\textcolor{ForestGreen}{\comment{Elena: {#1}}}}
\newcommand{\todo}[1]{\textcolor{blue}{\comment{To Do: {#1}}}}
\newcommand{\tkcomment}[1]{\textcolor{Teal}{\comment{Tristan: {#1}}}}
\newcommand{\jscomment}[1]{\textcolor{olive}{\comment{Jaydon: {#1}}}}
\newcommand{\jwcomment}[1]{\textcolor{violet}{\comment{John: {#1}}}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%% choose your presentation style:
\mode<presentation>
{
  \usetheme{Copenhagen} %%%
 \usecolortheme{beaver}

%%% set style for ovelays: lists (and other text) appearing one item at a time
%%% This will create a dimmed preview of next item:
\setbeamercovered{transparent}
%%% This will hide it entirely:
%\setbeamercovered{invisible}
}
%% if you don't want page numbers to show: 
\setbeamertemplate{footline}[page number]{}

%%%% 25 minutes time slot, including questions 

\begin{document}
\title{A beginner-friendly environment for exploring error messages in the Clojure programming language.}
\author{Tristan Kalvoda, Elena Machkasova, Jaydon Stanislowski, and John Walbran}
\institute[UMN Morris] % (optional, but mostly needed)
{
 % \inst{1}%
  University of Minnesota, Morris
}
\date[]  
{Midwest Instruction and Computing Symposium, April 2025}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}

  \frametitle{Outline}
\tableofcontents
\end{frame}

\section{Overview of Clojure and Its Error Messages}

\subsection{Clojure language and Syntax}
\begin{frame}
\frametitle{Clojure Language and Syntax}
What is Clojure? - Clojure language and Syntax
\begin{itemize}
  \item Clojure is a part of the Lisp language family
  \item Syntax
  \begin{itemize}
    \item prefix notation (operators before operands).
    \item expressions are surrounded by parentheses.
  \end{itemize}
\end{itemize}
Example: \texttt{(/ 9 3)} denotes 9 divided by 3
\end{frame}

\begin{frame}
  \frametitle{Clojure Language and Syntax}
  \begin{itemize}
    \item Clojure is implemented in Java and runs on the Java Virtual Machine (JVM)
    % \begin{itemize}
      % \item executed code compiles to JVM bytecode \emcomment{I corrected the line below slightly. Not sure if you need this line.}
    % \end{itemize}
    \item Clojure code \(\rightarrow\) Java code \(\rightarrow\) JVM bytecode \(\rightarrow\) \\ executed on JVM
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Clojure Language and Syntax}
  Clojure's REPL
  \begin{itemize}
    \item interactive environment for code evaluation
    \item Read \(\rightarrow\) Evaluate \(\rightarrow\) Print \(\rightarrow\) Loop
  \end{itemize}
  \includegraphics{../resources/cljScreenshot.JPG}  
\end{frame}

\subsection{Clojure's Error Messages}
\begin{frame}
  \frametitle{Clojure's Error Messages}
  Clojure Exceptions
  \begin{itemize}
    \item an event or error that disrupts the normal flow of a program's execution
    \item Clojure syntax errors will also result in a Java exception %\emcomment{mention that it is a Java exception}
  \end{itemize}
  Error Messages
  \begin{itemize}
    \item generate when a exception occurs
    \item provide error type, cause, and location
  \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Clojure's Error Messages}
    Anatomy of a Clojure Error Message \\
    \texttt{=> (/ 9 0)} \\
    \texttt{Execution error (ArithmeticException) at user/eval1 (REPL:1).} \\
    \texttt{Divide by zero}
    \begin{itemize}
      \item \texttt{ArithmeticException}: The type of error that occurred.
      \item \texttt{user/eval1 (REPL:1)}: The location where the error happened (in this case, REPL, line 1).
      \item \texttt{Divide by zero}: The description of the error's cause.
    \end{itemize}
\end{frame}

\section{Babel Project}
\subsection{Motivation and Goals}

\begin{frame}
    \frametitle{Motivation and Goals}
    Motivation
    \begin{itemize}
        \item Want to design a learning tool for beginners to Clojure and programming as a whole
        \item Clojure error messages contain awkward phrasing that may impede understanding
    \end{itemize}
    \textbf{Example} \\
    Consider the error produced by the form below. What does it mean? \\
    \texttt{=> (count 1)} \\
    \texttt{Execution error (UnsupportedOperationException) at user/eval1529 (REPL:1).} \\
    \texttt{count not supported on this type: Long} \\
\end{frame}

\begin{frame}
    \frametitle{Motivation and Goals}
    Goals
    \begin{itemize}
        \item Build an interactive, beginner-friendly tool for error processing in Clojure
        \item Simplify error messages to be more intuitive, removing jargon and clutter \\
        \jscomment{More stuff here? Or delete entirely?}
    \end{itemize}
\end{frame}

\subsection{Setup}
\begin{frame}
    \frametitle{Setup}
    Overview of Babel
    \begin{itemize}
        \item Replaces native Clojure error messages
        \item Messages produced by Babel broadly fall into two types:
    \end{itemize}
    \textbf{Spec errors}
    \begin{itemize}
        \item Babel makes use of the Clojure \textit{spec} library to catch errors on most core function calls
        \item This allows specifications on existing Clojure functions (see next slide)
    \end{itemize}
    \textbf{Non-spec errors}
    \begin{itemize}
        \item Regex is used to identify simpler, more common messages, e.g. division by zero
        \item We maintain a dictionary of these errors
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Setup}
    About \textit{spec}
    \begin{itemize}
        \item Tooling to define requirements on properties of a sequence or collection
        \item Function arguments come in a sequence
        \item Requirements are predicates, e.g., can be used to check argument types, count, values, etc.
        \item We bind specs to core Clojure functions, forcing an error if requirements aren't met
        \item Error reports from spec are far more detailed than native Clojure error messages
    \end{itemize}
\end{frame}

\begin{frame}
    Usage
    \begin{itemize}
        \item Launching a REPL server in the Babel repository allows the tool to "hook" to it
        \item All messages displayed in the terminal are generated by Babel rather than Clojure
    \end{itemize}
    Incomplete. This slide will talk a bit more about how Babel operates in the REPL's terminal window; doesn't currently have IDE integration but could be a nice future goal. Babel can also be run with separate files, though a bit clunky 
\end{frame}

\subsection{Exception Processing}

\begin{frame}
\frametitle{Exception Processing}
Incomplete. This slide will describe how Babel manipulates the messages it receives to produce the message seen by the end user. The exception data is "classified" and passed to one of many helper functions which returns a new string. The modified message is printed to the terminal in place of the original message.
\end{frame}

\section{Morse Viewers}
%Include a discussion of inspiration, (Joe Lane)
% Show default morse visually.
% Discuss the fact that REPL hooks are specific
% Simplify the end things.
\begin{frame}{Sending Data to Morse}
  \begin{itemize}
    %Babel provides overly-specific hooks to provide error messages.
    \item<1-> The Clojure REPL does not provide the proper hooks to effectively manipulate error message data.
    \item<2-> To get around this, we need to initialize Babel within a sub-REPL of the parent REPL session.
    \item<3-> Creating a sub-REPL allows us to introduce hooks that let us add preprocessing steps.
  \end{itemize}
\end{frame}

\begin{frame}{Sub-REPL hooks}
  Babel uses the following hooks as part of error processing:
  \begin{itemize}
    \item<1-> \texttt{:init} Behavior on startup, launches a new Morse session connected to the current REPL.
    \item<2-> \texttt{:eval} Behavior on form evaluation. Stores the command and sends it to REPL and Morse.
    \item<3-> \texttt{:caught} Behavior on caught exception. Processes the error in Babel, and changes the Exception-\>String processing to instead create a vector of labelled pairs.  
  \end{itemize}
\end{frame}

\section{Current State of the Project and Future Work}
\begin{frame}{Current State of the Project}
  \begin{itemize}
    \item<1-> We have existing error messages without labels for many common errors of core functions.
    \item<2-> We can connect Morse to a REPL session, and have mirroring form evaluation.
    \item<3-> Most of the work this year was spent structuring things for integration with Morse viewers.
    \item<4-> The introduction of the error labeling and prototyping this was pivotal in enabling data formatting.
    \item<5-> We currently have a small number of error messages labeled for demonstration purposes.
  \end{itemize}
\end{frame}

\subsection{Screenshots}
\begin{frame}
  \begin{figure}
    \centering
    \includegraphics[width=\textwidth]{../resources/CljDefaultEven.png}
    \caption{The output for the form \texttt{(even? 1 2)} in default Clojure.}
    \label{fig:defaultclj}
  \end{figure}
\end{frame}

\begin{frame}
  \begin{figure}
    \centering
    \includegraphics[width=\textwidth, height=0.25\textheight]{../resources/BabelREPL.png}
    \caption{The output for the form \texttt{(even? 1 2)} in Babel through the REPL.}
    \label{fig:BabelREPL}
  \end{figure}
\end{frame}

\begin{frame}
  \begin{figure}
    \centering
    \includegraphics[width=\textwidth]{../resources/BabelViewerExample.png}
    \caption{The output for the form \texttt{(even? 1 2)} in Babel with Morse.}
    \label{fig:defaultclj}
  \end{figure}
\end{frame}

\subsection{Future Work}
\begin{frame}{Future Work}
  \begin{itemize}
    \item<1-> Expand data labeling to all Babel error messages, expanding our ability to use Morse viewers.
    \item<2-> Add hover text to viewers for specific terms to add definitions and supplementary information to the presented error message.
    \item<3-> Refining the end user work flow between working code and erroring code.
    \item<4-> Develop Morse viewers for other information, such as the stack trace, and full java error messages.
  \end{itemize}
  \end{frame}

\begin{frame}{Future Work (cont.)}
  \begin{itemize}
    \item<1-> We plan to run a usability study about our developments after we have greater feature coverage.
    \item<2-> We are going to use the results to guide further design.
    \item<3-> We hope to explore IDE (VSCode) integration for possible work-flow refinements.
    %Overview of the VSCode extension development world.
    %https://code.visualstudio.com/api
    %Webview display, allows us to reuse existing viewer code.
    %https://code.visualstudio.com/api/extension-guides/webview
    %Language protocol guide: (LSP, syntax highlighting, etc.)
    %https://code.visualstudio.com/api/language-extensions/overview
  \end{itemize}
\end{frame}

\begin{frame}{Acknowledgements}
This work was supported in part by Morris Academic Partnership (MAP) and UMN Undergraduate Research Opportunity (UROP).  \\ 

\vspace*{0.2in}

We thank Joe Lane for introducing us to Morse tools and for numerous helpful discussions.
\end{frame}

\begin{frame}
  \frametitle{Discussion}
Questions?
\end{frame}

\end{document}
